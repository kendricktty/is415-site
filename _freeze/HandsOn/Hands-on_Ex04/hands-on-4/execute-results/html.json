{
  "hash": "a57554b9c9a22b71e6224ae03374feda",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"H4: Network Constrained Spatial Point Patterns Analysis\"\nsubtitle: \"Hands-On Exercise 4\"\nauthor: \"Kendrick Teo\"\ndate: \"2024-08-30\"\ndate-modified: \"last-modified\"\n\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n\n\n\n## H4.1 Overview and Data\n\n**Network Constrained Spatial Point Patterns Analysis (NetSPPA)** is a collection of *spatial point patterns analysis* (SPPA) methods special developed for analysing spatial point event occurs on or alongside a network. Examples of networks are road, train and river networks, while examples of spatial point events include locations of events like crime, or facilities like schools and parks.\n\nThis exercise will be on the `spNetwork` package, which serves to derive network kernel density estimation (NKDE), as well as to perform network G- and K-function analysis. Continuing on our theme of childcare centres, we will analyise the spatial distribution of childcare centres in [Punggol](https://en.wikipedia.org/wiki/Punggol). Two geospatial datasets in ESRI shapefile format will be used, namely:\n\n* `Punggol_St`, a line featureset storing information on Punggol's road network, and;\n* `Punggol_CC`, a point featureset storing the locations of Punggol's childcare centres.\n\n## H4.2 Installing and launching R packages\n\nThe R packages to be used today are:\n\n* `spNetwork`, for performing SPPA procedures like KDE and K-functions on the network. It can also be used to build spatial matrices to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances.\n* `sf`\n* `tmap`, particularly the `leaflet` API, which helps us plot cartographic-quality static point pattern maps or interactive maps.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pacman::p_load(sf, spNetwork, tmap, tidyverse)\n```\n:::\n\n\n\n\n\n## H4.3 Data Import, Preparation and Visualisation\n\nAs always, the first step is to import our geospatial datasets into RStudio as `sf` dataframes.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# network <- st_read(dsn=\".../data/geospatial\", \n#                    layer=\"Punggol_St\")\n# network\n# childcare <- st_read(dsn=\".../data/geospatial\",\n#                      layer=\"Punggol_CC\")\n# childcare\n# plot(st_geometry(network))\n# plot(childcare, add=T, col='blue', pch=19)\n```\n:::\n\n\n\n\n\n## H4.4 Network KDE Analysis\n\n**Network KDE (NKDE) analysis** can be performed by using appropriate functions from the `spNetwork` package.\n\n### H4.4.1 Preparing lixel objects\n\nBefore finding the NKDE, we need to first cut our `SpatialLines` objects into *lixels* with a specified minimal distance. We can do this by calling `lixelize_lines()` as shown. In the code chunk below:\n\n* The length of a lixel, taken in with the `lx_length` parameter, is set to `700` metres, and;\n* The minimum length of a lixel, as defined in the `mindist` parameter, is `375` metres.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# lixels <- lixelize_lines(network, \n#                          700, \n#                          mindist = 375)\n```\n:::\n\n\n\n\n\nAfter cutting, the length of the final lixel, if shorter than the minimum distance, is added to the previous lixel. If `mindist` is not defined (`NULL`), then it is `maxdist / 10`. Segments that are already shorter than the minimum distance are also not modified.\n\n### H4.4.2 Generating line centre points\n\nNext, the code chunk below will generate a `SpatialPointsDataFrame` (i.e. samples) with line centre points. These points are located at the centre of the line based on its length.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# samples <- lines_center(lixels)\n```\n:::\n\n\n\n\n\n### H4.4.3 Performing NKDE\n\nWe are now ready to compute the NKDE by using the following code chunk.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# densities <- nkde(network, \n#                   events = childcare,\n#                   w = rep(1, nrow(childcare)),\n#                   samples = samples,\n#                   kernel_name = \"quartic\",\n#                   bw = 300, \n#                   div= \"bw\", \n#                   method = \"simple\", \n#                   digits = 1, \n#                   tol = 1,\n#                   grid_shape = c(1,1), \n#                   max_depth = 8,\n#                   agg = 5, \n#                   sparse = TRUE,\n#                   verbose = FALSE)\n```\n:::\n\n\n\n\n\nSome interesting ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}