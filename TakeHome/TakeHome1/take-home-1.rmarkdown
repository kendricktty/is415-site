---
title: "TH1: Geospatial Analytics for Social Good"
image: "../../_site/HandsOn/Hands-on_Ex03/hands-on-3_files/figure-html/unnamed-chunk-42-1.png"
subtitle: "Take Home Exercise 1: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar"
author: "Kendrick Teo"
date: "2024-09-07"
date-modified: "last-modified"

execute: 
  eval: true
  echo: true
  freeze: true
---




## TH1.1 Setting the Scene

Millions of people have their lives shattered by armed conflict every year. One of these is the [**Myanmar Civil War**](https://en.wikipedia.org/wiki/Myanmar_civil_war_(2021%E2%80%93present)), a significant escalation of the long-running [Myanmar Conflict](https://en.wikipedia.org/wiki/Myanmar_conflict) in response to the [2021 coup d'etat](https://en.wikipedia.org/wiki/2021_Myanmar_coup_d%27%C3%A9tat).

Geospatial analtyics holds the potential to address complex problems facing society, such as this one. This study serves to discover the sptial and spatio-temporal distribution (spread) of the armed conflict in Myanmar by applying spatial point pattern analysis (SPPA) methods.

## TH1.2 The Data

Armed conflict data in Myanmar between 2010 and 2023 was downloaded from the [Armed Conflict Location & Event Database (ACLED)](https://acleddata.com/), an independent, impartial, international non-profit organization collecting data on violent conflicts and protests in all countries and territories in the world. We will be superimposing these locations with the geogrpahical boundary and subdivisions of the country, from the **Myanmar Information Management Unit** (MIMU).

We are interested in conflict events from 2019 onwards - starting from a year before the COVID-19 pandemic and 2 years before the 2021 coup - cumulating into the civil war of today.

## TH1.3 Importing and transforming armed conflict data and administrative boundary data into `sf` and `tibble` dataframes

### TH1.3.1 Loading R packages and aspatial data

The `R` packages we will use today are:

- `sf`
- `tmap`
- `spatstat`
- `sparr`
- `raster`
- `maptools`




```{r}
pacman::p_load(sf, raster, spatstat, sparr, tmap, tidyverse)
acled_mya <- read_csv("data/2021-01-01-2024-09-16-Southeast_Asia-Myanmar.csv")
head(acled_mya)
```




### TH1.3.2 Loading and plotting geospatial data

Three representations of Myanmar's geography exist on the MIMU repository - `Admin1` subdivides the country into its states and regions only, while `Admin2` subdivides the country by its smaller districts, and `Admin3` its townships. Further, the ACLED labels each incident with all 3 representations. For simplicity and ease of understanding, we shall use the `Admin1` representation.




```{r}
mmr_admin1 <- st_read(dsn = "data/mmr_polbnda_adm1_250k_mimu_1", layer = "mmr_polbnda_adm1_250k_mimu_1")
mmr_admin1
qtm(mmr_admin1)
```




### TH1.3.3 Creating `sf` data frame from aspatial data

The ACLED `tibble` contains coordinates, making it useful for plotting on our map as points. We can therefore use it to create an `sf` data frame using which we can plot our points on a map. The EPSG format of the import coordinates should be [`4326`](https://epsg.io/4326), corresponding to the WGS84 Geographic Coordinate System.




```{r}
acled_mya_sf <- st_as_sf(acled_mya, coords = c("longitude", "latitude"), crs = 4326)
```




The EPSG area code for Myanmar is [`4239`](https://epsg.io/4239), while the WGS 84-compatible code is [`32647`](https://epsg.io/32647). Since we're creating an `owin` object later, we need to first convert our coordinate system.




```{r}
acled_mya_sf <- acled_mya_sf %>% st_transform(crs = 32647)
mmr_admin1 <- mmr_admin1 %>% st_transform(crs = 32647)
tm_shape(mmr_admin1) + tm_polygons() + tm_shape(acled_mya_sf) + tm_dots(size = 0.05)
```




Additionally, since the data is timestamped, we are able to plot and compare the frequency of conflict events *over time*. Before we do, though, we need to standardise the date stamps, then compartmentalise them into their year, month and day components, so that we can perform spatial-temporal point patterns analysis (STPPA) later. We will also aim to segregate events by whether or not they occurred before the coup on **February 1, 2021**.

A visualisation of the spatial-temporial distribution of points can be found in **Annex A**. Notice the consistent appearance throughout the entire study period of a large cluster of points towards the west of the country - roughly the location of Rahkine state on the border with Bangladesh.




```{r}
acled_mya_sf <- acled_mya_sf %>%
    mutate(event_date = dmy(event_date)) %>%
    mutate(DayOfYear = yday(event_date)) %>%
    mutate(Month_num = format(event_date, "%Y-%m")) %>%  # Year-Month format
    mutate(Month_fac = factor(format(event_date, "%B %Y"))) %>% # Full month
    mutate(Quarter_num = year(event_date) * 10 + quarter(event_date)) %>%
    mutate(Quarter = paste0(year(event_date), "-", quarter(event_date), "Q"))  # Quarter format
    # mutate(BeforeCoup = ifelse(event_date < as.Date("2021-02-01"), "Before", "After"))
acled_mya_sf
# beforeAfterCoup <- unique(acled_mya_sf$BeforeCoup)
quarters <- unique(acled_mya_sf$Quarter)
print(length(quarters))
quarters
```

```{r}
tm_shape(mmr_admin1) + tm_polygons() + tm_shape(acled_mya_sf) + tm_dots(size = 0.05) + tm_facets(by="Quarter_num", free.coords=FALSE, drop.units = TRUE)

# Select quarters to plot STKDE so that it runs faster
selected_quarters = c("2024-3Q", "2023-1Q", "2021-2Q", "2021-1Q")
```




### TH1.3.4 Final steps to prepare for KDE

Finally, before moving on to our KDE, 

#### TH1.3.4.1 Using `owin` to confine study area within Myanmar borders




```{r}
mmr_admin1_owin <- as.owin(mmr_admin1)
plot(mmr_admin1_owin)
# summary(mmr_admin1_owin)
```




#### TH1.3.4.2 Creating quarterly `ppp` objects for KDE and merging `owin`

The code chunk below will create `ppp` objects for each quarter within the study period, as well as before and after the coup. Each object will be combined with the Myanmar `owin` object and rescaled from metres to kilometres for KDE calculation.




```{r}
# Extract quarterly armed conflict events and save to a list
# acled_ppp_beforeAfterCoup_list <- list()
# for (coupStatus in beforeAfterCoup) {
#   print(coupStatus)
#   acled_mya_beforeCoup_subset <- subset(acled_mya_sf, acled_mya_sf$BeforeCoup == coupStatus)
#   acled_mya_beforeCoup_ppp <- as.ppp(acled_mya_beforeCoup_subset)
#   acled_mya_beforeCoup_ppp <- acled_mya_beforeCoup_ppp[mmr_admin1_owin]
#   acled_ppp_beforeAfterCoup_list[[as.character(coupStatus)]] <- acled_mya_beforeCoup_ppp
#   plot(acled_mya_beforeCoup_ppp, main=paste("Armed conflict ppp object ", coupStatus, " coup"))
# }
```

```{r}
# Extract quarterly armed conflict events and save to a list
acled_ppp_list <- list()
for (quarter in quarters) {
  print(quarter)
  acled_mya_quarters_subset <- subset(acled_mya_sf, acled_mya_sf$Quarter == quarter)
  acled_mya_quarter_ppp <- as.ppp(acled_mya_quarters_subset)
  acled_mya_quarter_ppp <- acled_mya_quarter_ppp[mmr_admin1_owin]
  acled_ppp_list[[as.character(quarter)]] <- acled_mya_quarter_ppp
  plot(acled_mya_quarter_ppp, main=paste("Armed conflict ppp object for ", quarter))
}
```




Finally, the process will be repeated but for the entire set at once.



```{r}
#| echo: false
# Create all-encompassing ppp
# acled_mya_ppp <- as.ppp(acled_mya_sf)
# acled_mya_ppp <- acled_mya_ppp[mmr_admin1_owin]
# acled_mya_ppp.km <- rescale.ppp(acled_mya_ppp, 1000, "km")
# plot(acled_mya_ppp)
# acled_mya_ppp
```




## TH1.4 Interlude: A brief history of Myanmar's ethnic groups

## TH1.5 First Order SPPA - KDE

Kernel density estimation (KDE) serves to compute the *intensity* of a point distribution. It has two general steps: first to compute the point intensity, followed by spatial interpolation using a kernel function. Using KDE, we can determine the general region of Myanmar with the highest incidence of armed conflict.

### TH1.5.1 Overall Fixed-Bandwidth KDE




```{r}
# overall_fixed_kde <- density(acled_mya_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
# plot(overall_fixed_kde, main="Overall fixed bandwidth KDE")
```



### TH1.5.2 Overall adaptive-bandwidth KDE



```{r}
# overall_adaptive_kde <- adaptive.density(acled_mya_ppp.km, method="kernel")
# plot(overall_adaptive_kde, main="Overall adaptive bandwidth KDE")
```




### TH1.5.3 Quarterly fixed-bandwidth KDE




```{r}
# Create a list to store KDE results and track quarters for each quarter
fixed_kde <- list()
for (quarter in selected_quarters) {
  print(quarter)
  ppp_item <- acled_ppp_list[[as.character(quarter)]]
  ppp_item <- rescale.ppp(ppp_item, 1000, "km")
  ppp_item
  # Compute KDE and append to list
  each_kde <- density(ppp_item, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
  fixed_kde[[as.character(quarter)]] <- each_kde
}
for (quarter in selected_quarters) {
  plot(fixed_kde[[as.character(quarter)]], main = paste("Fixed bandwidth KDE for ", quarter))
}

```



### TH1.5.4 Quarterly adaptive-bandwidth KDE




```{r}
# Create a list to store adaptive KDE results and track quarters for each quarter
adaptive_kde <- list()
for (quarter in selected_quarters) {
  print(quarter)
  ppp_item <- acled_ppp_list[[as.character(quarter)]]
  ppp_item <- rescale.ppp(ppp_item, 1000, "km")
  ppp_item
  # Compute KDE and append to list
  each_kde <- adaptive.density(ppp_item, method="kernel")
  adaptive_kde[[as.character(quarter)]] <- each_kde
}
```

```{r}
for (quarter in selected_quarters) {
  plot(adaptive_kde[[as.character(quarter)]], main = paste("Adaptive bandwidth KDE for", quarter))
}
```




## TH1.6 First Order STPPA: Spatio-temporal KDE




```{r}
acled_mya_sf_quarters <- acled_mya_sf %>% select(Quarter_num)
acled_mya_quarters_ppp <- as.ppp(acled_mya_sf_quarters)
acled_mya_quarters_ppp <- acled_mya_quarters_ppp[mmr_admin1_owin]
plot(acled_mya_quarters_ppp)

st_kde <- spattemp.density(acled_mya_quarters_ppp)
summary(st_kde)
```

```{r}
for (quarter in quarters) {
  plot(st_kde, override.par=FALSE, fix.range=TRUE, main=paste("Spatial-temporal KDE for", quarter))
}
```




## TH1.7 First-order SPPA: Nearest Neighbour Analysis

To determine whether the plotted armed conflict events are clustered, dispersed or random, we can use the Clark-Evans test. Since tensions between Myanmar's different ethnic groups already existed before the 2021 coup, it would be a good idea to run the test on the subsets of data both before and after the coup.




```{r}
ppp_item <- acled_ppp_beforeAfterCoup_list[[as.character("Before")]]
print("Clark Evans Test: Before Coup")
clarkevans.test(ppp_item, correction = "none", clipregion = "mmr_admin1_owin", alternative = c("clustered"), nsim = 9)
```

```{r}
ppp_item <- acled_ppp_beforeAfterCoup_list[[as.character("After")]]
print("Clark Evans Test: After Coup")
clarkevans.test(ppp_item, correction = "none", clipregion = "mmr_admin1_owin", alternative = c("clustered"), nsim = 9)
```




## TH1.7 Second-order SPPA

Second order SPPA deals with variations in observations due to the way they interact with one another. The methods used for second order SPPA are the F-, G-, K- and L-functions. In this section, we will perform second-order SPPA on the conflict dataset, applying the F-, G-, K- and L-functions on subsets of the data before and after the 2021 coup.

### TH1.7.1 F-function




```{r}
for (quarter in selected_quarters) {
  print(quarter)
  ppp_item <- acled_ppp_beforeAfterCoup_list[[as.character(quarter)]]
  F_function <- Fest(ppp_item)
  plot(F_function, main = paste("F function for", quarter))
  
  # Perform complete spatial randomness test
  csr <- envelope(ppp_item, Fest, nsim=9)
  plot(csr, main = paste("Complete spatial randomness test for F function for", quarter))
}
```




### TH1.7.2 G-function




```{r}
for (quarter in selected_quarters) {
  print(paste(coupStatus, " coup"))
  ppp_item <- acled_ppp_beforeAfterCoup_list[[as.character(quarter)]]
  G_function <- Gest(ppp_item, correction = "border")
  plot(G_function, xlim=c(0, 500), main = paste("G function for", quarter))
  
  # Perform complete spatial randomness test
  csr <- envelope(ppp_item, Gest, nsim=9)
  plot(csr, main = paste("Complete spatial randomness test for G function for", quarter))
}
```




### TH1.7.3 K-function




```{r}
for (quarter in selected_quarters) {
  print(paste(coupStatus, " coup"))
  ppp_item <- acled_ppp_beforeAfterCoup_list[[as.character(quarter)]]
  K_function <- Kest(ppp_item, correction = "Ripley")
  plot(K_function, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)", main = paste("K function for", quarter))
  
  # Perform complete spatial randomness test
  csr <- envelope(ppp_item, Kest, nsim=9, rank=1, glocal=TRUE)
  plot(csr, . - r ~ r, xlab="d", ylab="K(d)-r", main = paste("Complete spatial randomness test for K function for", quarter))
}
```




### TH1.7.4 L-function




```{r}
for (quarter in selected_quarters) {
  print(paste(coupStatus," coup"))
  ppp_item <- acled_ppp_beforeAfterCoup_list[[as.character(quarter)]]
  L_function <- Lest(ppp_item, correction = "Ripley")
  plot(L_function, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)", main = paste("L function for", quarter))
  
  # Perform complete spatial randomness test
  csr <- envelope(ppp_item, Kest, nsim=9, rank=1, glocal=TRUE)
  plot(csr, . - r ~ r, xlab="d", ylab="L(d)-r", main = paste("Complete spatial randomness test for L function for", quarter))
}
```




## References

1. Raleigh, C., Kishi, R. & Linke, A. Political instability patterns are obscured by conflict dataset scope conditions, sources, and coding choices. Humanit Soc Sci Commun 10, 74 (2023). https://doi.org/10.1057/s41599-023-01559-4

## Annex A: Spatial-temporal distribution of armed conflict occurrences in Myanmar between 2019 and 2023




```{r}
tm_shape(mmr_admin1) + tm_polygons() + tm_shape(acled_mya_sf) + tm_dots(size = 0.1) + tm_facets(by="Quarter", free.coords=FALSE, drop.units=TRUE, ncol=3, nrow=1)
```




## Annex B: All quarterly fixed-bandwidth KDE plots




```{r}
for (quarter in quarters) {
  plot(fixed_kde[[as.character(quarter)]], main = paste("Fixed bandwidth KDE for ", quarter))
}
```




## Annex C: All quarterly adaptive-bandwidth KDE plots




```{r}
for (quarter in quarters) {
  plot(adaptive_kde[[as.character(quarter)]], main = paste("Adaptive bandwidth KDE for ", quarter))
}
```
